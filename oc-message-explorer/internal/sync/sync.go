package sync

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"oc-message-explorer/internal/database"
	"oc-message-explorer/internal/models"
	"oc-message-explorer/internal/utils"
)

type SyncProgress struct {
	TotalMessages int    `json:"totalMessages"`
	Processed     int    `json:"processed"`
	Phase         string `json:"phase"`
	Message       string `json:"message"`
	Error         string `json:"error,omitempty"`
}

type SyncManager struct {
	db               *database.Database
	store            any
	dataPath         string
	msgPath          string
	partPath         string
	progressCallback func(SyncProgress)
	cancelChan       chan struct{}
	running          bool
	mu               sync.RWMutex
}

func NewSyncManager(db *database.Database, store any, dataPath string, progressCallback func(SyncProgress)) *SyncManager {
	msgPath := filepath.Join(dataPath, "storage", "message")
	partPath := filepath.Join(dataPath, "storage", "part")

	return &SyncManager{
		db:               db,
		store:            store,
		dataPath:         dataPath,
		msgPath:          msgPath,
		partPath:         partPath,
		progressCallback: progressCallback,
		cancelChan:       make(chan struct{}),
	}
}

func (sm *SyncManager) StartSync() error {
	sm.mu.Lock()
	if sm.running {
		sm.mu.Unlock()
		return fmt.Errorf("sync already running")
	}
	sm.running = true
	sm.mu.Unlock()

	go sm.performSync()
	return nil
}

func (sm *SyncManager) CancelSync() {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	if sm.running {
		close(sm.cancelChan)
		sm.cancelChan = make(chan struct{})
		sm.running = false
	}
}

func (sm *SyncManager) performSync() {
	defer func() {
		sm.mu.Lock()
		sm.running = false
		sm.mu.Unlock()
	}()

	sm.reportProgress(SyncProgress{Phase: "init", Message: "Starting sync..."})

	isEmpty, err := sm.db.IsEmpty()
	if err != nil {
		sm.reportProgress(SyncProgress{Phase: "error", Message: "Failed to check database", Error: err.Error()})
		return
	}

	messageNodes := make(map[string]*models.MessageNode)

	sm.reportProgress(SyncProgress{Phase: "reading", Message: "Reading OpenCode messages..."})

	sessions, err := os.ReadDir(sm.msgPath)
	if err != nil {
		sm.reportProgress(SyncProgress{Phase: "error", Message: "Failed to read OpenChat message directory", Error: err.Error()})
		return
	}

	totalSessions := len(sessions)
	sm.reportProgress(SyncProgress{Phase: "reading", Message: fmt.Sprintf("Found %d sessions...", totalSessions), TotalMessages: totalSessions})

	sessionCount := 0
	totalMessages := 0

	for _, sessionDir := range sessions {
		select {
		case <-sm.cancelChan:
			sm.reportProgress(SyncProgress{Phase: "cancelled", Message: "Sync cancelled by user"})
			return
		default:
		}

		if !sessionDir.IsDir() {
			continue
		}

		sessionPath := filepath.Join(sm.msgPath, sessionDir.Name())
		messageFiles, err := os.ReadDir(sessionPath)
		if err != nil {
			log.Printf("Failed to read session %s: %v", sessionDir.Name(), err)
			continue
		}

		msgCount := 0
		for _, msgFile := range messageFiles {
			if !strings.HasSuffix(msgFile.Name(), ".json") {
				continue
			}

			msgFilePath := filepath.Join(sessionPath, msgFile.Name())
			msgData, err := os.ReadFile(msgFilePath)
			if err != nil {
				log.Printf("Failed to read message file %s: %v", msgFile.Name(), err)
				continue
			}

			var ocMsg models.OpenCodeMessage
			if err := json.Unmarshal(msgData, &ocMsg); err != nil {
				log.Printf("Failed to unmarshal message %s: %v", msgFile.Name(), err)
				continue
			}

			var nodeType string
			var nodeTags []string

			switch ocMsg.Role {
			case "assistant":
				nodeType = "response"
				nodeTags = []string{ocMsg.Agent, ocMsg.Role}
			case "system":
				nodeType = "system"
				nodeTags = []string{ocMsg.Agent, ocMsg.Role}
			case "user":
				nodeType = "user"
				summaryTitle := utils.GetSummaryTitle(ocMsg.Summary)
				if utils.IsAutoGenerated(summaryTitle) {
					nodeType = "auto"
					nodeTags = []string{ocMsg.Agent, ocMsg.Role, "auto-generated"}
				} else {
					nodeTags = []string{ocMsg.Agent, ocMsg.Role}
				}
			default:
				nodeType = "prompt"
				nodeTags = []string{ocMsg.Agent, ocMsg.Role}
			}

			title := utils.GetSummaryTitle(ocMsg.Summary)
			if title == "" {
				if ocMsg.Role == "assistant" {
					title = "AI response"
				} else if ocMsg.Role == "system" {
					title = "System message"
				} else {
					title = fmt.Sprintf("%s message", ocMsg.Role)
				}
			}

			node := &models.MessageNode{
				ID:        ocMsg.ID,
				Type:      nodeType,
				Content:   "",
				Summary:   title,
				Timestamp: utils.FormatTimestamp(ocMsg.Time.Created),
				ParentID:  ocMsg.ParentID,
				Children:  []string{},
				Tags:      nodeTags,
				Expanded:  false,
				Selected:  false,
				SessionID: ocMsg.SessionID,
				HasLoaded: false,
			}

			messageNodes[ocMsg.ID] = node
			msgCount++
			totalMessages++

			if msgCount%100 == 0 || msgCount == 1 {
				sm.reportProgress(SyncProgress{
					Phase:         "reading",
					Message:       fmt.Sprintf("Read %d/%d sessions (%d msgs)...", sessionCount+1, totalSessions, totalMessages),
					Processed:     totalMessages,
					TotalMessages: totalMessages,
				})
			}
		}

		log.Printf("Loaded %d messages from session %s", msgCount, sessionDir.Name())
		sessionCount++
	}

	sm.reportProgress(SyncProgress{
		Phase:         "reading",
		Message:       fmt.Sprintf("Completed reading %d sessions with %d messages total", sessionCount, totalMessages),
		Processed:     totalMessages,
		TotalMessages: totalMessages,
	})

	sm.reportProgress(SyncProgress{Phase: "building", Message: "Building parent-child relationships..."})

	for _, node := range messageNodes {
		if node.ParentID != "" {
			if parent, exists := messageNodes[node.ParentID]; exists {
				parent.Children = append(parent.Children, node.ID)
			}
		}
	}

	log.Printf("Built relationships for %d messages from %d sessions", len(messageNodes), sessionCount)

	sm.reportProgress(SyncProgress{
		Phase:         "building",
		Message:       fmt.Sprintf("Built relationships for %d messages", len(messageNodes)),
		Processed:     len(messageNodes),
		TotalMessages: len(messageNodes),
	})

	sm.reportProgress(SyncProgress{Phase: "writing", Message: "Writing to database..."})

	if isEmpty {
		if err := sm.writeFullSync(messageNodes, sessionCount); err != nil {
			sm.reportProgress(SyncProgress{Phase: "error", Message: "Failed to write full sync", Error: err.Error()})
			return
		}
	} else {
		if err := sm.writeIncrementalSync(messageNodes); err != nil {
			sm.reportProgress(SyncProgress{Phase: "error", Message: "Failed to write incremental sync", Error: err.Error()})
			return
		}
	}

	sm.reportProgress(SyncProgress{
		Phase:         "complete",
		Message:       fmt.Sprintf("Sync complete: %d messages", len(messageNodes)),
		Processed:     len(messageNodes),
		TotalMessages: len(messageNodes),
	})
}

func (sm *SyncManager) writeFullSync(messageNodes map[string]*models.MessageNode, sessionCount int) error {
	folder := &models.Folder{
		ID:        "openchat",
		Name:      "OpenChat History",
		Color:     "#e94560",
		CreatedAt: time.Now().Format(time.RFC3339),
		Nodes:     messageNodes,
	}

	if err := sm.db.InsertFolder(folder); err != nil {
		return err
	}

	processed := 0
	for _, node := range messageNodes {
		select {
		case <-sm.cancelChan:
			return fmt.Errorf("sync cancelled")
		default:
		}

		if err := sm.db.InsertNode("openchat", node); err != nil {
			log.Printf("Failed to insert node %s: %v", node.ID, err)
			continue
		}

		processed++
		if processed%100 == 0 {
			sm.reportProgress(SyncProgress{
				Phase:         "writing",
				Message:       fmt.Sprintf("Written %d/%d messages...", processed, len(messageNodes)),
				Processed:     processed,
				TotalMessages: len(messageNodes),
			})
		}
	}

	log.Printf("Wrote %d messages to database", processed)

	sm.reportProgress(SyncProgress{
		Phase:         "writing",
		Message:       fmt.Sprintf("Written %d messages to database", processed),
		Processed:     processed,
		TotalMessages: len(messageNodes),
	})

	return nil
}

func (sm *SyncManager) writeIncrementalSync(messageNodes map[string]*models.MessageNode) error {
	existingFolder, err := sm.db.GetFolder("openchat")
	if err != nil {
		return err
	}

	if existingFolder == nil {
		return sm.writeFullSync(messageNodes, 0)
	}

	processed := 0
	newMessages := 0

	for id, node := range messageNodes {
		select {
		case <-sm.cancelChan:
			return fmt.Errorf("sync cancelled")
		default:
		}

		_, exists := existingFolder.Nodes[id]
		if !exists {
			if err := sm.db.InsertNode("openchat", node); err != nil {
				log.Printf("Failed to insert node %s: %v", node.ID, err)
				continue
			}
			newMessages++
		}

		processed++
		if processed%100 == 0 {
			sm.reportProgress(SyncProgress{
				Phase:         "writing",
				Message:       fmt.Sprintf("Processed %d, found %d new messages...", processed, newMessages),
				Processed:     processed,
				TotalMessages: len(messageNodes),
			})
		}
	}

	log.Printf("Incremental sync: processed %d messages, %d new", processed, newMessages)

	sm.reportProgress(SyncProgress{
		Phase:         "complete",
		Message:       fmt.Sprintf("Incremental sync complete: %d new messages", newMessages),
		Processed:     processed,
		TotalMessages: len(messageNodes),
	})

	return nil
}

func (sm *SyncManager) reportProgress(progress SyncProgress) {
	if sm.progressCallback != nil {
		sm.progressCallback(progress)
	}
}

func (sm *SyncManager) IsRunning() bool {
	sm.mu.RLock()
	defer sm.mu.RUnlock()
	return sm.running
}
